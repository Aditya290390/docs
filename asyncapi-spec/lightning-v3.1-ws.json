{
  "asyncapi": "3.0.0",
  "info": {
    "title": "Lightning V3.1 Text-to-Speech WebSocket API",
    "version": "3.1.0",
    "description": "WebSocket-based streaming text-to-speech API for Lightning V3.1 model",
    "contact": {
      "name": "Waves API Support",
      "url": "https://waves-api.smallest.ai/support",
      "email": "support@smallest.ai"
    },
    "license": {
      "name": "Proprietary"
    }
  },
  "servers": {
    "production": {
      "host": "waves-api.smallest.ai",
      "pathname": "/api/v1/lightning-v3.1/get_speech/stream",
      "protocol": "wss",
      "description": "Production WebSocket API endpoint",
      "security": [
        {
          "$ref": "#/components/securitySchemes/bearerAuth"
        }
      ]
    }
  },
  "channels": {
    "/api/v1/lightning-v3.1/get_speech/stream": {
      "address": "/api/v1/lightning-v3.1/get_speech/stream",
      "messages": {
        "ttsRequest.message": {
          "name": "TTSRequest",
          "contentType": "application/json",
          "payload": {
            "type": "object",
            "required": ["voice_id", "text"],
            "properties": {
              "voice_id": {
                "type": "string",
                "description": "The ID of the voice to use"
              },
              "text": {
                "type": "string",
                "description": "The text to convert to speech"
              },
              "max_buffer_flush_ms": {
                "type": "integer",
                "description": "The maximum time (in ms) to wait for more input before generating output. It flushes when either this time is reached or enough input is received for optimal outputâ€”whichever comes first. This is useful for input streams. Defaults to 0",
                "default": 0,
                "maximum": 1000,
                "minimum": 0
              },
              "continue": {
                "type": "boolean",
                "description": "This setting controls whether the system should buffer and wait for more input after receiving the current one. If not set, it assumes no more input is coming.",
                "default": false
              },
              "flush": {
                "type": "boolean",
                "description": "This setting controls whether the system should flush the current buffer.",
                "default": false
              },
              "complete_backoff_ms": {
                "type": "number",
                "description": "The time in ms to wait after the last chunk is sent before sending the complete response. Default is 4000ms. Maximum is 10000ms.",
                "default": 4000,
                "minimum": 0,
                "maximum": 10000
              },
              "language": {
                "type": "string",
                "description": "The language code, available options: `en`, `hi`",
                "default": "en",
                "enum": ["en", "hi"]
              },
              "sample_rate": {
                "type": "integer",
                "description": "Audio sample rate in Hz",
                "default": 44100,
                "enum": [8000, 16000, 24000, 44100]
              },
              "speed": {
                "type": "number",
                "description": "Speaking speed multiplier",
                "minimum": 0.5,
                "maximum": 2.0,
                "default": 1
              }
            },
            "examples": [
              {
                "voice_id": "ryan",
                "text": "Hello, this is a sample text to convert to speech.",
                "max_buffer_flush_ms": 0,
                "continue": false,
                "flush": false,
                "language": "en",
                "sample_rate": 24000,
                "speed": 1,
                "consistency": 0.5,
                "enhancement": 1,
                "similarity": 0
              }
            ]
          }
        },
        "ttsResponse.message": {
          "name": "TTSResponse",
          "contentType": "application/json",
          "payload": {
            "type": "object",
            "properties": {
              "request_id": {
                "type": "string",
                "description": "Unique identifier for the TTS request"
              },
              "status": {
                "type": "string",
                "enum": ["chunk", "complete"],
                "description": "Status of the TTS request, `chunk` indicates incoming audio chunk, `complete` indicates completion."
              },
              "data": {
                "type": "object",
                "properties": {
                  "audio": {
                    "type": "string",
                    "description": "Base64-encoded audio chunk"
                  }
                }
              }
            }
          }
        }
      }
    }
  },
  "operations": {
    "ttsRequest": {
      "action": "receive",
      "channel": {
        "$ref": "#/channels/~1api~1v1~1lightning-v3.1~1get_speech~1stream"
      },
      "summary": "Send text-to-speech request",
      "messages": [
        {
          "$ref": "#/channels/~1api~1v1~1lightning-v3.1~1get_speech~1stream/messages/ttsRequest.message"
        }
      ]
    },
    "ttsResponse": {
      "action": "send",
      "channel": {
        "$ref": "#/channels/~1api~1v1~1lightning-v3.1~1get_speech~1stream"
      },
      "summary": "Receive audio stream chunks",
      "messages": [
        {
          "$ref": "#/channels/~1api~1v1~1lightning-v3.1~1get_speech~1stream/messages/ttsResponse.message"
        }
      ]
    }
  },
  "components": {
    "securitySchemes": {
      "bearerAuth": {
        "type": "http",
        "scheme": "bearer",
        "bearerFormat": "JWT",
        "description": "Bearer token authentication"
      }
    },
    "schemas": {
      "AudioChunk": {
        "type": "object",
        "properties": {
          "data": {
            "type": "object",
            "properties": {
              "audio": {
                "type": "string",
                "description": "Base64-encoded audio chunk"
              }
            }
          }
        }
      },
      "CompletionStatus": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string",
            "description": "Unique identifier for the TTS request"
          },
          "status": {
            "type": "string",
            "enum": ["complete"],
            "description": "Indicates that the streaming is complete"
          }
        }
      },
      "ErrorResponse": {
        "type": "object",
        "properties": {
          "status": {
            "type": "string",
            "enum": ["error"]
          },
          "error": {
            "type": "object",
            "properties": {
              "message": {
                "type": "string"
              },
              "code": {
                "type": "string"
              }
            }
          }
        }
      }
    }
  }
}
